{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>goose is a database migration tool. Manage your database schema by creating incremental SQL changes and/or Go functions.</p> <p> Installing goose</p>"},{"location":"#background","title":"Background","text":"<p>github.com/pressly/goose is a fork of bitbucket.org/liamstask/goose with the following changes:</p> <ul> <li>No config files</li> <li>Default <code>goose</code> binary can migrate SQL files only</li> <li>Go migrations:</li> <li>We don't go build Go migrations functions on-the-fly from within the <code>goose</code> binary</li> <li>Instead, we let you create your own custom <code>goose</code> binary, register your Go migration functions explicitly and run complex migrations with your own *sql.DB connection</li> <li>Go migration functions let you run your code within an SQL transaction, if you use the *sql.Tx argument</li> <li>The <code>goose</code> pkg is decoupled from the binary:</li> <li><code>goose</code> pkg doesn't register any SQL drivers anymore, thus no driver panic() conflict within your codebase!</li> <li><code>goose</code> pkg doesn't have any vendor dependencies anymore</li> <li>We use timestamped migrations by default but recommend a hybrid approach of using timestamps in the development process and sequential versions in production.</li> </ul>"},{"location":"installation/","title":"Installing goose","text":"<p>This project is both a command-line utility (CLI) and a library. This section covers how to install or build <code>goose</code>.</p> <p>You can also install a pre-compiled binary from the GitHub release page. Don't forget to set the executable bit on macOS and Linux.</p>"},{"location":"installation/#macos","title":"macOS","text":""},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>If you're on a Mac, the easiest way to get started is with the Homebrew package manager.</p> <pre><code>brew install goose\n</code></pre> <p>An installation script is available that works on macOS, see  Linux.</p>"},{"location":"installation/#linux","title":"Linux","text":"<p>At the root of the project is an <code>install.sh</code> script to download and install the binary.</p> <pre><code>curl -fsSL \\\n    https://raw.githubusercontent.com/pressly/goose/master/install.sh |\\\n    sh #(1)!\n</code></pre> <ol> <li> <p>Since this script is downloading directly to <code>/usr/local/bin</code>, you may need to <code>sudo sh</code>. You'll     often see an error such as:</p> <p><code>curl: (23) Failure writing output to destination</code></p> <p>Alternatively, change the output to a directory your current user can write to by setting <code>GOOSE_INSTALL</code>.</p> </li> </ol> <p> The default output directory is <code>/usr/local/bin</code>, but can be changed by setting <code>GOOSE_INSTALL</code>. Do not include <code>/bin</code>, it is added by the script.</p> <p> Optionally, a version can be specified as an argument. The default is to download the <code>latest</code> version.</p> <pre><code>curl -fsSL \\\n    https://raw.githubusercontent.com/pressly/goose/master/install.sh |\\\n    GOOSE_INSTALL=$HOME/.goose sh -s v3.5.0\n</code></pre> <p>This will install <code>goose version v3.5.0</code> in directory:</p> <pre><code>$HOME/.goose/bin/goose\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<p>No installation script is available, but you can download a pre-built Windows binary or build from source if Go is installed.</p>"},{"location":"installation/#building-from-source","title":"Building from source","text":"<p>You'll need Go 1.16 or later.</p> <pre><code>go install github.com/pressly/goose/v3/cmd/goose@latest\n</code></pre> <p>Alternatively, you can clone the repository and build from source.</p> <pre><code>git clone https://github.com/pressly/goose\ncd goose\ngo mod tidy\ngo build -o goose ./cmd/goose\n\n./goose --version\n# goose version:(devel)\n</code></pre> <p>This will produce a <code>goose</code> binary ~15M in size because it includes all supported drivers.</p>"},{"location":"installation/#lite-version","title":"Lite version","text":"<p>For a lite version of the binary, use the exclusive build tags. Here's an example where we target only <code>sqlite</code>, and the resulting binary is ~8.7M in size.</p> <pre><code>go build \\\n    -tags='no_postgres no_clickhouse no_mssql no_mysql' \\\n    -o goose ./cmd/goose\n</code></pre> <p>Bonus, let's make this binary smaller by stripping debugging information.</p> <pre><code>go build \\\n    -ldflags=\"-s -w\" \\\n    -tags='no_postgres no_clickhouse no_mssql no_mysql' \\\n    -o goose ./cmd/goose\n</code></pre> <p>We're still only targeting <code>sqlite</code> and reduced the binary to ~6.6M.</p> <p>You can go further with a tool called <code>upx</code>, for more info check out Shrink your go binaries with this one weird trick.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2021/welcome/","title":"Hello, docs!","text":"<p>Introductory blog post. I guess I'll write a few words.</p> <p><code>goose</code> was originally open sourced in late 2012 by Liam Staskawicz on bitbucket.org/liamstask/goose with an MIT license.</p> <p>Great project at the time. Remember, Go itself reached version 1.0 in the same year (March, 2012).</p> <p>However, there were a few items left to be desired, and so the Pressly team forked the project in 2016 and has maintained it since. You can read the Goals of this fork section for more info. But that's enough looking back. Let's look into the future.</p> <p>We aim to continue maintaining <code>goose</code>; adding new features, fixing bugs and providing developer resources to improve the experience. There are also newer features of the standard library and community packages we may consider adopting.</p> <p>There are lots of issues to triage, and a few burning features we need to implement.</p> <p>After thousands of migrations in production we've learned a thing or two, and have ideas on how to improve <code>goose</code> even more. Stay tuned!</p>"},{"location":"blog/2021/embed-sql-migrations/","title":"Embedding migrations","text":""},{"location":"blog/2021/embed-sql-migrations/#embedding-migrations","title":"Embedding migrations","text":"<p>Go continues to be boring while sprinkling quality of life features. One of the recent additions was the ability to embed files at compile time. Click here for go1.16 release notes.</p> <p>Sine many users compile <code>goose</code> themselves, this new embed feature paves the way for embedding SQL files directly into the <code>goose</code> binary. This was already possible with existing tools, however, now that embedding is part of the standard library it's never been easier to offer this feature.</p>"},{"location":"blog/2021/embed-sql-migrations/#but-why","title":"But why?","text":"<p>We'll save \"why would I compile <code>goose</code> myself?\" for another post, instead we'll focus on why embedding files is an improvement to existing workflows.</p> <p>A typical workflow looks something like this:</p> <ol> <li>Developer introduces new SQL migration file</li> <li>File gets merged to <code>main</code> and a <code>goose</code> binary is built</li> <li>The binary along with SQL files is copied into a docker container</li> <li>The docker container is run as a singleton against the database before the application starts up</li> </ol> <p>One of the cumbersome things about this workflow is that the <code>goose</code> binary and the migration files need to be shipped together and the directory structure has to be maintained.</p> <p>But now that <code>goose</code> natively supports embedding files it simplifies the workflow. A <code>goose</code> binary is shipped without any file dependencies, i.e., the migration files are baked into the binary itself.</p>"},{"location":"blog/2021/embed-sql-migrations/#gotchas","title":"Gotchas","text":"<p>We did not implement this in a backwards-compatible way, i.e., the feature is not guarded with build tags. Which means starting with v3.1.0 you must be on go1.16 and up.</p> <p>For older <code>goose</code> versions you may still pin v3.0.1.</p>"},{"location":"blog/2021/embed-sql-migrations/#try-it-out","title":"Try it out!","text":"<p>Remember, the files to be embedded must be relative to the source file(s). Here is what our directory structure might look like:</p> <pre><code>.\n\u251c\u2500\u2500 embed_example.sql\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 go.sum\n\u2514\u2500\u2500 internal\n    \u2514\u2500\u2500 goose\n        \u251c\u2500\u2500 main.go\n        \u2514\u2500\u2500 migrations\n            \u2514\u2500\u2500 00001_create_users_table.sql\n</code></pre> <p>Here is a fully working example using an in-memory database (SQLite).</p> <pre><code>package main\n\nimport (\n    \"database/sql\"\n    \"embed\"\n    \"log\"\n\n    _ \"github.com/mattn/go-sqlite3\"\n    \"github.com/pressly/goose/v3\"\n)\n\n//go:embed migrations/*.sql\nvar embedMigrations embed.FS // (1)\n\nfunc main() {\n    log.SetFlags(0)\n    db, err := sql.Open(\"sqlite3\", \"embed_example.sql\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    goose.SetDialect(\"sqlite3\")\n    goose.SetBaseFS(embedMigrations) // (2)\n\n    if err := goose.Up(db, \"migrations\"); err != nil { // (3)\n        panic(err)\n    }\n    if err := goose.Version(db, \"migrations\"); err != nil {\n        log.Fatal(err)\n    }\n    rows, err := db.Query(`SELECT * FROM users`)\n    if err != nil {\n        log.Fatal(err)\n    }\n    var user struct {\n        ID       int\n        Username string\n    }\n    for rows.Next() {\n        if err := rows.Scan(&amp;user.ID, &amp;user.Username); err != nil {\n            log.Fatal(err)\n        }\n        log.Println(user.ID, user.Username)\n    }\n}\n</code></pre> <ol> <li> <p>This <code>//go:embed</code> is a special directive that tells the Go tooling to read files from the package    directory or subdirectories at compile time and stores them in the a variable of type    <code>embed.FS</code>.The <code>embed.FS</code> will store a read-only collection of *.sql files.</p> </li> <li> <p>Pass the <code>embed.FS</code> variable to <code>goose</code>. This instructs <code>goose</code> to use the embedded filesystem    instead of opening files from the underlying os.</p> </li> <li> <p>You still have to tell <code>goose</code> which directory contains the .sql files. This implementation    allowed us to keep existing functions without having to change the function signature or add new    functions.It is a drop-in feature that enables the caller to either use the os (as    before) or use embedded filesystem without changing parts of their existing programs.</p> </li> </ol> <p>A sample repo can be found at mfridmn/goose-demo</p> <p>From the root of the directory you can build the binary, and to prove it has no dependencies move it to your home directory and run the binary. This will create a embed_example.sql file for sqlite database. Cool right?!</p> <pre><code>go build -o goosey internal/goose/main.go\nmv goosey $HOME\ncd $HOME\n./goosey\n</code></pre> <p>Output:</p> <pre><code>OK    00001_create.sql\ngoose: no migrations to run. current version: 1\ngoose: version 1\n0 root\n1 goosey\n</code></pre>"},{"location":"blog/2021/better-tests/","title":"Better tests with containers","text":"<p>Managing state is hard. Managing database state is even harder. And coordinating state within a test suite is just always a bad time.</p> <p>But it doesn't have to be this way!</p> <p>There is a fantastic Go package called ory/dockertest that allows you to spin up ephemeral docker containers. It'll work both locally (assuming you have Docker installed) and in your Continuous Integration (CI) pipelines.</p> <p>After applying thousands of migrations in production we know <code>goose</code> is production-ready and does the right thing. But we have plans to add more functionality to <code>goose</code>, and integration tests are a welcome addition to the <code>goose</code> test-suie.</p> <p>In a recent <code>goose</code> release (PR#276) we added container-based database tests. These tests spin up a fresh database per test. Yes, that's right, we're talking dozens of containers.</p> <p>After each test is completed the container is cleaned up, something like this:</p> <pre><code>t.Cleanup(func() {\n    if err := pool.Purge(container); err != nil {\n        log.Printf(\"failed to purge resource: %v\", err)\n    }\n})\n</code></pre> <p>For integration tests this is perfect. We can spin up a fresh lightweight container for each test, such as <code>postgres:14-alpine</code>, and not worry about tests stomping on each other or having to coordinate state between tests.</p> <p>The entire thing is fast! Where tests run in parallel using <code>t.Parallel()</code> and the entire integration test-suite run in about 6-7s (for <code>postgres:14-alpine</code>).</p> <p>Check it out..</p> <pre><code>+--------+---------+----------------------------+---------+\n| STATUS | ELAPSED |            TEST            | PACKAGE |\n+--------+---------+----------------------------+---------+\n| PASS   |    5.77 | TestMigrateOutOfOrderDown  | e2e     |\n| PASS   |    5.54 | TestNowAllowMissingUpByOne | e2e     |\n| PASS   |    5.28 | TestAllowMissingUp         | e2e     |\n| PASS   |    4.60 | TestAllowMissingUpByOne    | e2e     |\n| PASS   |    4.48 | TestNotAllowMissing        | e2e     |\n| PASS   |    4.39 | TestMigrateUpTo            | e2e     |\n| PASS   |    4.31 | TestMigrateUpByOne         | e2e     |\n| PASS   |    3.69 | TestMigrateUp              | e2e     |\n| PASS   |    2.30 | TestMigrateFull            | e2e     |\n+--------+---------+----------------------------+---------+\n\n+--------+---------+---------------------------------------+\n| STATUS | ELAPSED |                PACKAGE                |\n+--------+---------+---------------------------------------+\n| PASS   | 6.12s   | github.com/pressly/goose/v3/tests/e2e |\n+--------+---------+---------------------------------------+\n</code></pre> <p>So, next time you need a database in your containers</p>"},{"location":"blog/2021/out-of-order-migrations/","title":"Adding support for out-of-order migrations","text":"<p>Starting with <code>goose</code> v3.3.0 we added the ability to apply missing (out-of-order) migrations. Thanks for all the the community feedback over the years.</p> <p>Let's back it up, what are \"missing\" or \"out-of-order\" migrations?</p> <p>Suppose migration 1 and 4 are applied and then 2, 3, 5 are introduced. Prior to v3.3.0 <code>goose</code> would ignore migrations 2, 3 and apply only 5. Although this might seem odd, this is fairly consistent behaviour with other migration tools.</p> <p>However, many users were not satisfied with this behaviour, summarized as:</p> <ul> <li>migrations 2 and 3 are \"silently\" ignored</li> <li>unable to apply migrations 2 and 3 if newer versions have already been applied. To paraphrase this   comment:</li> </ul> <p>I would very much prefer just to apply Bill's migration and call it a day.</p> <p>This comment from <code>@zmoazeni</code> has stuck with me over the years.</p> <p>Given that <code>goose</code> maintains a full history of applied migrations in its <code>goose_db_version</code> table, we are able to resolve the database state against the migration files. And now, if missing (out-of-order) migrations are detected users can opt-in to apply them.</p> <p>Internally within Pressly (acquired by Alida) we suggested adopting the hybrid versioning approach. Briefly, in development developers create timestamped migrations, and subsequently when that PR is merged into the <code>main</code> branch its converted into a sequential migration. This is done with the <code>goose fix</code> command.</p> <p>Then when a release is cut and rolled out to production only sequential migrations are applied. It was a solution to the problem that worked for our team. Yes, yes.. this does require developers to be rebasing/merging and resolving conflicts (if any) between migrations.</p> <p></p> <ul> <li>A timestamped version uses a time-based format (second resolution): <code>20060102150405</code></li> <li>A sequential version is typically a low number</li> </ul> <p>There should never (at least in our lifetime) be a collision between timestamped and sequential versions.</p> <p>Buttttt..... as we listened to community feedback, and saw the rise in the number of <code>goose</code> forks (mainly to support missing migrations), we decided the community was right. The hybrid versioning approach is not for everyone and it wasn't fair for us to impose this strict restriction.</p> <p>I think this comment summarized it well:</p> <p>We should meet users in the middle (lots of great feedback from the community) and give them the flexibility to use <code>goose</code> as they see fit. The responsibility will be shifted from the tool itself, to the end user.</p> <p>To recap, this is the new behaviour of <code>goose</code>:</p> <p>If you attempt to apply missing (out-of-order) migrations <code>goose</code> will raise an error (previously <code>goose</code> would ignore these migrations). However, if you do want to apply these missing migrations pass <code>goose</code> the <code>-allow-missing</code> flag, or if using as a library supply the functional option <code>goose.WithAllowMissing()</code> to Up, UpTo or UpByOne commands.</p> <p>More details can be found in the Changelog and the issue #262.</p> <p>Hope folks find this useful. More awesome things are planned for <code>goose</code> \ud83d\ude80.</p> <p>ps. consider dropping pressly/goose a \u2b50\ufe0f if you find this package useful.</p>"},{"location":"blog/2021/no-version-migrations/","title":"Ad-hoc migrations with no versioning","text":"<p>This post describes a new feature recently added to <code>goose</code> -- the ability to apply migrations with no versioning. A common use case is to seed a database with data after versioned migrations have been applied.</p> <p>If you think of versioned migrations as the blueprint for a house (the schema), then unversioned migrations are like the furnishings inside (the data).</p> <p>A GitHub user @soggycactus stated the problem well (#235 comment):</p> <p>... I always find myself creating some sort of wrapper that allows me to use goose to seed my local and development environments with test data</p>"},{"location":"blog/2021/no-version-migrations/#brief-summary","title":"Brief Summary","text":"<ul> <li>keep versioned migrations in a dedicated directory (e.g., ./schema/migrations)</li> <li>continue running <code>goose</code> commands like normal: <code>goose -dir ./schema/migrations up</code></li> <li>add unversioned migrations to a different directory (e.g., ./schema/seed)</li> <li>run <code>goose</code> commands with <code>-no-versioning</code> flag using seed directory</li> </ul> <p>By adding <code>-no-versioning</code> flag (CLI) or supplying <code>WithNoVersioning()</code> option (library), we instruct <code>goose</code> to apply migrations but to ignore tracking the version in the database schema table.</p>"},{"location":"blog/2021/no-version-migrations/#but-why","title":"But why?","text":"<p>A common use case is to seed an environment with data, such as local development environment or integration tests. Because we don't want this data to be applied to production, we keep it separate from the versioned migrations in a different directory.</p> <p>Seed data: think many <code>INSERT INTO</code> statements in up migrations and <code>DELETE FROM</code> or <code>TRUNCATE</code> in down migrations.</p> <ul> <li>new developer joins, spins up a database, applies versioned migrations but requires \"seed\" data to   get started</li> <li>integration or end-end tests that rely on pre-existing data. It's common to have your application   create data, but sometimes you just want data to be there for external tests not involving your   API</li> <li>optimizing delicate queries on a database with pre-populated data. Avoid writing queries against   an empty database</li> </ul> <p>Remember, if your application does requires some static, pre-existing data, then just insert it along with your regular versioned schema migrations.</p>"},{"location":"blog/2021/no-version-migrations/#example","title":"Example","text":"<p>Seeding integration tests and wiping data, without having to reset the database schema.</p> <p>Let's use an example:</p> <pre><code>.\n\u2514\u2500\u2500 schema\n    \u251c\u2500\u2500 migrations\n    \u2502   \u251c\u2500\u2500 00001_add_users_table.sql\n    \u2502   \u251c\u2500\u2500 00002_add_posts_table.sql\n    \u2502   \u2514\u2500\u2500 00003_alter_users_table.sql\n    \u2514\u2500\u2500 seed\n        \u251c\u2500\u2500 00001_seed_users_table.sql\n        \u2514\u2500\u2500 00002_seed_posts_table.sql\n</code></pre> <p>Running the following command creates the desired shape of the database:</p> <pre><code>goose -dir ./schema/migrations up\n</code></pre> <p>Assuming you're using the default goose table name <code>goose_db_version</code> then querying this table will return 3 versioned migrations.</p> <p>Now, suppose we want to run integration tests against a database that contains pre-populated data. Running the following command applies two migrations but it does not track their version in the database.</p> <pre><code>goose -dir ./schema/seed -no-versioning up\n</code></pre> <p>If you run the initial command again:</p> <pre><code>goose -dir ./schema/migrations up\n</code></pre> <p><code>goose</code> will output \"no new migrations found\". Because <code>goose</code> knows we already applied 3 migrations, so no further work to do.</p> <p>But, if you run the second command again:</p> <pre><code>goose -dir ./schema/seed -no-versioning up\n</code></pre> <p><code>goose</code> doesn't know about unversioned migrations (due to the <code>-no-versioning</code> flag) so it will apply the seed migrations once again. Depending how you wrote the migrations, this may or may not succeed.</p> <p>Lastly, we're done with our integration test. The neat thing with the <code>-no-versioning</code> flag is it enables you to wipe the data without having to migrate the entire database down and up again.</p> <p>Running the following command will apply the down migrations in your seed files, in reverse order:</p> <pre><code>goose -dir ./schema/seed -no-versioning down-to 0\n# or\ngoose -dir ./schema/seed -no-versioning reset\n</code></pre> <p>These two commands are the same--applying all down migrations starting from the highest to the lowest numbered migration files in the schema directory.</p>"},{"location":"blog/2021/no-version-migrations/#final-thoughts","title":"Final Thoughts","text":"<p>With the <code>-no-versioning</code> flag (CLI) or <code>WithNoVersioning()</code> option (library) you now have the ability to apply arbitrary SQL statements to the database.</p> <p>Just remember, these operations are not tracked (versioned) and are intended to be used in development/testing environments.</p>"},{"location":"blog/2021/visualizing-up-down-commands/","title":"A tour of goose up and down commands","text":"<p>A while ago a co-op student, who happened to be a visual leaner, asked if it were possible to explain <code>goose</code> commands visually. At the time we were still at an office, so we gathered around the whiteboard and doodled some diagrams.</p> <p>This post captures some of those whiteboard sketches, which seemed to help.</p>"},{"location":"blog/2021/visualizing-up-down-commands/#up-commands","title":"up commands","text":"<code>goose up</code> <p>migrate all pending migrations to the most recent version</p> <code>goose up-by-one</code> <p>migrate a single pending version</p> <code>goose up-to N</code> <p>migrate to a specific pending version, where N is a migration number</p>"},{"location":"blog/2021/visualizing-up-down-commands/#up-examples","title":"up examples","text":"<p>Let's illustrate up commands with a concrete example.</p> <p>Suppose our ./schema/migrations folder contains 11 migration files. We have previously applied 8 migrations and 3 migrations are currently pending.</p> <p>Running <code>goose version</code> returns: goose: version 8</p> <p>Running <code>goose status</code> returns:</p> <pre><code>Applied At                  Migration\n=======================================\nSun Dec 19 20:09:48 2021 -- 00001_a.sql\nSun Dec 19 20:09:48 2021 -- 00002_b.sql\nSun Dec 19 20:09:48 2021 -- 00003_c.sql\nSun Dec 19 20:09:48 2021 -- 00004_d.sql\nSun Dec 19 20:09:48 2021 -- 00005_e.sql\nSun Dec 19 20:09:48 2021 -- 00006_f.sql\nSun Dec 19 20:09:48 2021 -- 00007_g.sql\nSun Dec 19 20:09:48 2021 -- 00008_h.sql\nPending                  -- 00009_i.sql\nPending                  -- 00010_j.sql\nPending                  -- 00011_k.sql\n</code></pre> <ul> <li>Running <code>goose up</code> applies all 3 pending migrations: 9, 10 and 11</li> <li>Running <code>goose up-by-one</code> applies only migration 9</li> <li>Running <code>goose up-to 8</code> does nothing, since 8 has already been applied</li> <li>Running <code>goose up-to 10</code> applies migrations 9 and 10</li> </ul> <p></p>"},{"location":"blog/2021/visualizing-up-down-commands/#down-commands","title":"down commands","text":"<code>goose down</code> <p>migrate the latest version down</p> <code>goose down-to N</code> <p>migrate down to a specific version, where N is a migration number</p>"},{"location":"blog/2021/visualizing-up-down-commands/#down-examples","title":"down examples","text":"<p>Let's illustrate down commands, continuing with the above example. We have previously applied all 11 migrations from the ./schema/migrations folder.</p> <p>Running <code>goose version</code> returns: goose: version 11</p> <p>Running <code>goose status</code> returns:</p> <pre><code>Applied At                  Migration\n=======================================\nSun Dec 19 21:31:11 2021 -- 00001_a.sql\nSun Dec 19 21:31:11 2021 -- 00002_b.sql\nSun Dec 19 21:31:11 2021 -- 00003_c.sql\nSun Dec 19 21:31:11 2021 -- 00004_d.sql\nSun Dec 19 21:31:11 2021 -- 00005_e.sql\nSun Dec 19 21:31:11 2021 -- 00006_f.sql\nSun Dec 19 21:31:11 2021 -- 00007_g.sql\nSun Dec 19 21:31:11 2021 -- 00008_h.sql\nSun Dec 19 21:31:11 2021 -- 00009_i.sql\nSun Dec 19 21:31:11 2021 -- 00010_j.sql\nSun Dec 19 21:31:11 2021 -- 00011_k.sql\n</code></pre> <ul> <li>Running <code>goose down</code> applies the down migration for 11</li> <li>Running <code>goose down-to 11</code> does nothing</li> <li>Running <code>goose down-to 9</code> applies the down migrations for 11 and 10</li> <li>Running <code>goose down-to 0</code> applies all down migrations</li> </ul> <p></p> <p>Bonus</p> <p><code>goose down-to 0</code> is the same as <code>goose reset</code>. Applying all down migrations.</p> <p><code>goose redo</code> is the same as <code>goose down</code> followed by <code>goose up-by-one</code>. Reapplying the latest migration.</p>"},{"location":"blog/2022/improving-clickhouse/","title":"Improving ClickHouse support","text":"<p>ClickHouse is a an open-source column-oriented database that is well-suited for analytical workloads. Over the past few years we've seen more and more demand for improved ClickHouse support in goose.</p> <p>To summarize:</p> <ul> <li>Upgraded to the latest <code>/v2</code> driver:   ClickHouse/clickhouse-go</li> <li>Full end-end tests against the docker image:   clickhouse/clickhouse-server</li> <li>Bug fixes and improvements</li> </ul> <p>The <code>/v2</code> driver changed the DSN format, so be prepared for a breaking change. This is actually a good thing, because it brings the format in-line with other databases.</p>"},{"location":"blog/2022/improving-clickhouse/#getting-started","title":"Getting started","text":"<p>Here's a quick tour of using goose against a running ClickHouse docker container.</p> <pre><code>docker run --rm -d \\\n    -e CLICKHOUSE_DB=clickdb \\\n    -e CLICKHOUSE_USER=clickuser \\\n    -e CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT=1 \\\n    -e CLICKHOUSE_PASSWORD=password1 \\\n    -p 9000:9000/tcp clickhouse/clickhouse-server:22-alpine\n</code></pre> <p>Once the container is running, we'll apply 3 migrations with goose. For the sake of this demo, we're using migrations from pressly/goose repository.</p> <p>At the time of this writing, goose supports 3 environment variables:</p> <pre><code>GOOSE_DRIVER\nGOOSE_DBSTRING\nGOOSE_MIGRATION_DIR\n</code></pre> <p>We use them in the following command for convenience. Otherwise you'll need to set the driver and database connection strings as CLI parameters and the migration directory with the <code>-dir</code> flag.</p> <pre><code>GOOSE_DRIVER=clickhouse \\\n    GOOSE_DBSTRING=\"tcp://clickuser:password1@localhost:9000/clickdb\" \\\n    GOOSE_MIGRATION_DIR=\"tests/clickhouse/testdata/migrations\" \\\n    goose up\n</code></pre> <p>Expected output following a successful migration.</p> <pre><code>2022/06/19 20:19:04 OK    00001_a.sql\n2022/06/19 20:19:04 OK    00002_b.sql\n2022/06/19 20:19:04 OK    00003_c.sql\n2022/06/19 20:19:04 goose: no migrations to run. current version: 3\n</code></pre>"},{"location":"blog/2022/improving-clickhouse/#check-migrations","title":"Check migrations","text":"<p>We can now use the <code>clickhouse-client</code> to poke around the server:</p>"},{"location":"blog/2022/improving-clickhouse/#show-tables","title":"Show tables","text":"<pre><code>clickhouse-client --vertical \\\n    --database clickdb --password password1 -u clickuser \\\n    -q 'SHOW TABLES'\n</code></pre> <p>Our migrations created the <code>goose_db_version</code> table, which stores migration data, and 2 new user tables: <code>clickstream</code> and <code>trips</code>.</p> <pre><code>Row 1:\n\u2500\u2500\u2500\u2500\u2500\u2500\nname: clickstream\n\nRow 2:\n\u2500\u2500\u2500\u2500\u2500\u2500\nname: goose_db_version\n\nRow 3:\n\u2500\u2500\u2500\u2500\u2500\u2500\nname: trips\n</code></pre>"},{"location":"blog/2022/improving-clickhouse/#show-all-data-from-clickstream-table","title":"Show all data from <code>clickstream</code> table","text":"<p>We used the sample data from the Getting Started with ClickHouse tutorial.</p> <pre><code>clickhouse-client --vertical \\\n    --database clickdb --password password1 -u clickuser \\\n    -q 'SELECT * FROM clickstream'\n</code></pre> <p>Output:</p> <pre><code>Row 1:\n\u2500\u2500\u2500\u2500\u2500\u2500\ncustomer_id:      customer3\ntime_stamp:       2021-11-07\nclick_event_type: checkout\ncountry_code:\nsource_id:        307493\n\nRow 2:\n\u2500\u2500\u2500\u2500\u2500\u2500\ncustomer_id:      customer2\ntime_stamp:       2021-10-30\nclick_event_type: remove_from_cart\ncountry_code:\nsource_id:        0\n\nRow 3:\n\u2500\u2500\u2500\u2500\u2500\u2500\ncustomer_id:      customer1\ntime_stamp:       2021-10-02\nclick_event_type: add_to_cart\ncountry_code:     US\nsource_id:        568239\n</code></pre>"},{"location":"blog/2022/overview-sql-file/","title":"SQL migration files and goose annotations","text":"<p>In this post we'll explore SQL migration files and <code>+goose</code> annotation comments, which are used to parse SQL statements and optionally modify how migrations are executed.</p> <p>As of this writing there are five annotations:</p> <pre><code>-- +goose Up\n-- +goose Down\n-- +goose StatementBegin\n-- +goose StatementEnd\n-- +goose NO TRANSACTION\n</code></pre> <p>bonus</p> <p>In addition to SQL migration files, the <code>goose</code> package can be used to write Go-based migrations and track both SQL and Go migrations in the same way.</p> <p>See repository example for Go migrations. We'll do a deep dive in a future post. Stay tuned!</p>"},{"location":"blog/2022/overview-sql-file/#quick-start","title":"Quick start","text":"<p>Here's a copy/pasteable <code>.sql</code> migration file to get started:</p> <pre><code>-- +goose Up\nSELECT 'up SQL query';\n\n-- +goose Down\nSELECT 'down SQL query';\n</code></pre> <p>Remember, annotations are captured as comments and cannot have leading spaces:</p> <pre><code>-- +goose Up \u2705\n    -- +goose Up \u274c (error because leading whitespace)\n</code></pre>"},{"location":"blog/2022/overview-sql-file/#the-basics","title":"The basics","text":"<p>A SQL migration file must have a <code>.sql</code> extension and is prefixed with either a timestamp or a sequential number.</p> <p>There is a handy <code>goose create</code> command to stub out migration files in a consistent way:</p>"},{"location":"blog/2022/overview-sql-file/#timestamp","title":"timestamp","text":"<pre><code>$ goose -dir migrations create add_users_table sql\nCreated new file: migrations/20230201093158_add_users_table.sql\n</code></pre>"},{"location":"blog/2022/overview-sql-file/#sequential","title":"sequential","text":"<pre><code>$ goose -dir migrations -s create add_users_table sql # (1)! Created new file:\nmigrations/00001_add_users_table.sql\n</code></pre> <ol> <li>The <code>-s</code> flag instructs goose to create new migration files in sequential order. Timestamp     is the default.</li> </ol> <p>A SQL migration file can have both Up and Down migrations. For the curious, there is an open issue ( #374) requesting support for migrations to be split in separate files.</p> <p>Each SQL migration file is expected to have exactly one <code>-- +goose Up</code> annotation.</p> <p>The <code>-- +goose Down</code> annotation is optional, but recommended, and must come after the Up annotation within the file. Example:</p> <pre><code>-- +goose Up\nSELECT 'up SQL query 1';\nSELECT 'up SQL query 2';\nSELECT 'up SQL query 3';\n\n-- +goose Down (1)\nSELECT 'down SQL query 1';\nSELECT 'down SQL query 2';\n</code></pre> <ol> <li> <p>The <code>-- +goose Down</code> annotation is optional, and may be omitted entirely if there are no down     migrations. Within the <code>.sql</code> file it must come after the <code>-- +goose Up</code> annotation.</p> <p>This is invalid:</p> <pre><code>-- +goose Down\nSELECT 'down SQL query';\n\n-- +goose Up\nSELECT 'up SQL query';\n</code></pre> </li> </ol> <p>Any statements following <code>-- +goose Up</code> will be executed as part of an up migration, and any statements following <code>-- +goose Down</code> will be executed as part of a down migration.</p>"},{"location":"blog/2022/overview-sql-file/#complex-statements","title":"Complex statements","text":"<p>By default, SQL statements are delimited by semicolons - in fact, query statements must end with a semicolon to be properly recognized by <code>goose</code>.</p> <p>More complex statements (PL/pgSQL) that have semicolons within them must be annotated with <code>-- +goose StatementBegin</code> and <code>-- +goose StatementEnd</code> to be properly parsed. For example:</p> <pre><code>-- +goose Up\n\n-- +goose StatementBegin\nCREATE OR REPLACE FUNCTION histories_partition_creation( DATE, DATE )\nreturns void AS $$\nDECLARE\n  create_query text;\nBEGIN\n-- This comment will be preserved.\n  -- And so will this one.\n  FOR create_query IN SELECT\n      'CREATE TABLE IF NOT EXISTS histories_'\n      || TO_CHAR( d, 'YYYY_MM' )\n      || ' ( CHECK( created_at &gt;= timestamp '''\n      || TO_CHAR( d, 'YYYY-MM-DD 00:00:00' )\n      || ''' AND created_at &lt; timestamp '''\n      || TO_CHAR( d + INTERVAL '1 month', 'YYYY-MM-DD 00:00:00' )\n      || ''' ) ) inherits ( histories );'\n    FROM generate_series( $1, $2, '1 month' ) AS d\n  LOOP\n    EXECUTE create_query;\n  END LOOP;  -- LOOP END\nEND;         -- FUNCTION END\n$$\nlanguage plpgsql;\n-- +goose StatementEnd\n</code></pre> <p>When <code>goose</code> detects a <code>-- +goose StatementBegin</code> annotation it continues parsing statement(s), ignoring semicolons, until <code>-- +goose StatementEnd</code> is detected. The resulting statement is stripped of leading and trailing comments / empty lines.</p> <p>Comments and empty lines within the statement are preserved!</p>"},{"location":"blog/2022/overview-sql-file/#multiple-statements","title":"Multiple statements","text":"<p>But that's not all, the Begin and End annotations can be used to combine multiple statements so they get sent as a single command instead of being sent one-by-one.</p> <p>This is best illustrated with a contrived example. Suppose we have a migration that creates a <code>users</code> table and adds 100,000 rows with distinct <code>INSERT</code>'s.</p> <pre><code>-- +goose Up\nCREATE TABLE users (\n    id int NOT NULL PRIMARY KEY,\n    username text,\n    name text,\n    surname text\n);\n\n-- (1)! Inserts:\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (1, 'gallant_almeida7', 'Gallant', 'Almeida7');\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (2, 'brave_spence8', 'Brave', 'Spence8');\n.\n.\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (99999, 'jovial_chaum1', 'Jovial', 'Chaum1');\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (100000, 'goofy_ptolemy0', 'Goofy', 'Ptolemy0');\n\n-- +goose Down\nDROP TABLE users;\n</code></pre> <ol> <li> <p>This is a contrived example. Normally this would be a set of batched <code>INSERT</code>'s with multiple     column values, each enclosed with parentheses and separated by commas, like so:</p> <pre><code>INSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\")\nVALUES\n  (1, 'gallant_almeida7', 'Gallant', 'Almeida7'),\n  (2, 'brave_spence8', 'Brave', 'Spence8');\n</code></pre> </li> </ol> <p>The Up migration contains 100,001 unique statements, all executed within the same transaction, but sent to the database one-by-one. This migration will take ~38s to complete due to the number of round trips.</p> <p>Using PostgreSQL as an example, here's what the database logs show:</p> <pre><code>LOG:  statement: INSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (1, 'gallant_almeida7', 'Gallant', 'Almeida7');\nLOG:  statement: INSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (2, 'brave_spence8', 'Brave', 'Spence8');\nLOG:  statement: INSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (3, 'lucid_bardeen6', 'Lucid', 'Bardeen6');\n[...] 100,000 log statements\n</code></pre> <p>However, if we want to combine the inserts into a single command, we can wrap them with <code>-- +goose StatementBegin</code> and <code>-- +goose StatementEnd</code> annotations. Note, a single command still contains several statements separated by semicolons, but they get sent to the server in the same query string like so: <code>\"INSERT INTO ...; INSERT INTO ...;\"</code>.</p> <pre><code>-- +goose Up\nCREATE TABLE users (\n    id int NOT NULL PRIMARY KEY,\n    username text,\n    name text,\n    surname text\n);\n\n-- +goose StatementBegin\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (1, 'gallant_almeida7', 'Gallant', 'Almeida7');\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (2, 'brave_spence8', 'Brave', 'Spence8');\n.\n.\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (99999, 'jovial_chaum1', 'Jovial', 'Chaum1');\nINSERT INTO \"users\" (\"id\", \"username\", \"name\", \"surname\") VALUES (100000, 'goofy_ptolemy0', 'Goofy', 'Ptolemy0');\n-- +goose StatementEnd\n\n-- +goose Down\nDROP TABLE users;\n</code></pre> <p>These annotations instruct <code>goose</code> to send a single command, which now consists of multiples statements delimited by semicolons, in one shot.</p> <p>Yes, that's a larger payload, but that's fine and the migration will execute in ~3s, which is an order of magnitude faster as compared to the previous example that ran in ~38s.</p>"},{"location":"blog/2022/overview-sql-file/#migrations-outside-transaction","title":"Migrations outside transaction","text":"<p>All statements within a migration file are run within a transaction. Some statements, like <code>CREATE DATABASE</code> or <code>CREATE INDEX CONCURRENTLY</code>, cannot be run within a transaction block.</p> <p>For such cases add the <code>-- +goose NO TRANSACTION</code> annotation, usually placed at the top of the file.</p> <p>This annotation instructs <code>goose</code> to run all statements within the file without transactions. This applies to all Up and Down statements within the file.</p> <pre><code>-- +goose NO TRANSACTION\n\n-- +goose Up\nCREATE INDEX CONCURRENTLY ON users (user_id);\n\n-- +goose Down\nDROP INDEX IF EXISTS users_user_id_idx;\n</code></pre>"},{"location":"commands/experimental/","title":"Experimental commands","text":"<p>Use with caution.</p> <p>Commands that are prefixed with beta, e.g.,</p> <pre><code>goose beta &lt;subcommand&gt;\n</code></pre> <p>Are experimental commands that may have breaking changes and do not have the same backward-compatible  gaurantee as stable commands. </p> <p>Although we try our best to avoid breaking changes, sometimes it is unavoidable for <code>beta</code> commands.</p> <p>At the moment there are 0 beta commands.</p>"},{"location":"commands/supported/","title":"Supported Commands","text":"<p>The following commands are part of the stable set of commands and will remain backwards compatible across minor/patch upgrades.</p>"},{"location":"commands/supported/#up","title":"up","text":"<p>Migrate the DB to the most recent version available</p>"},{"location":"commands/supported/#up-by-one","title":"up-by-one","text":"<p>Migrate the DB up by 1</p>"},{"location":"commands/supported/#up-to","title":"up-to","text":"<p>Migrate the DB to a specific VERSION</p>"},{"location":"commands/supported/#down","title":"down","text":"<p>Roll back the version by 1</p>"},{"location":"commands/supported/#down-to","title":"down-to","text":"<p>Roll back to a specific VERSION</p>"},{"location":"commands/supported/#redo","title":"redo","text":"<p>Re-run the latest migration</p>"},{"location":"commands/supported/#reset","title":"reset","text":"<p>Roll back all migrations</p>"},{"location":"commands/supported/#status","title":"status","text":"<p>Dump the migration status for the current DB</p>"},{"location":"commands/supported/#version","title":"version","text":"<p>Print the current version of the database</p>"},{"location":"commands/supported/#create","title":"create","text":"<p>Creates new migration file with the current timestamp</p>"},{"location":"commands/supported/#fix","title":"fix","text":"<p>Apply sequential ordering to migrations</p>"},{"location":"blog/archive/2022/","title":"2022","text":""},{"location":"blog/archive/2021/","title":"2021","text":""},{"location":"blog/category/blog/","title":"Blog","text":""},{"location":"blog/category/sql-migrations/","title":"SQL migrations","text":""},{"location":"blog/category/clickhouse/","title":"ClickHouse","text":""},{"location":"blog/category/general/","title":"General","text":""},{"location":"blog/category/testing/","title":"Testing","text":""},{"location":"blog/category/go-migrations/","title":"Go migrations","text":""}]}